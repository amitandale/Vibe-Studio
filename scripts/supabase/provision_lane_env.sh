#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: provision_lane_env.sh <lane> [--interactive] [--pg-password VALUE] [--random-pg-password]\
  [--pg-super-role VALUE] [--pg-super-password VALUE] [--edge-env-file PATH] [--force]

Provision a Supabase lane environment file with random secrets.

Options:
  --interactive           Securely prompt for the Postgres password (ignored if --pg-password is provided)
  --pg-password VALUE     Provide the Postgres password non-interactively
  --random-pg-password    Generate a strong Postgres password automatically (default when no password provided)
  --pg-super-role VALUE   Override the fallback superuser role used for maintenance (default: supabase_admin)
  --pg-super-password VALUE
                          Provide the fallback superuser password non-interactively
  --edge-env-file PATH    Override the default edge runtime env file path
  --force                 Overwrite the existing env file without prompting
  -h, --help              Show this help message

Lanes: main, work, codex
USAGE
}

if [[ ${1:-} == "-h" || ${1:-} == "--help" || $# -eq 0 ]]; then
  usage
  exit 0
fi

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "required command '$1' not found" >&2
    exit 1
  fi
}

require_cmd openssl
require_cmd jq
require_cmd python3

docker_available=false
if command -v docker >/dev/null 2>&1; then
  docker_available=true
fi

resolve_image_pin() {
  local ref="$1"
  if [[ "$docker_available" != true ]]; then
    echo "$ref"
    return 0
  fi

  if docker manifest inspect "$ref" >/dev/null 2>&1; then
    echo "$ref"
    return 0
  fi

  local base="$ref"
  if [[ "$ref" == *@* ]]; then
    base="${ref%@*}"
  fi

  local manifest_json=""
  if manifest_json=$(docker manifest inspect "$base" 2>/dev/null); then
    local digest=""
    digest=$(python3 -c 'import json, sys
try:
    data = json.load(sys.stdin)
except Exception:
    sys.exit(0)
candidates = []
descriptor = data.get("Descriptor") or data.get("descriptor")
if isinstance(descriptor, dict):
    value = descriptor.get("digest")
    if value:
        candidates.append(value)
for key in ("digest", "Digest"):
    value = data.get(key)
    if value:
        candidates.append(value)
for item in data.get("manifests", []):
    if isinstance(item, dict):
        value = item.get("digest") or item.get("Digest")
        if value:
            candidates.append(value)
if candidates:
    print(candidates[0])
' <<<"$manifest_json")
    if [[ -n "$digest" ]]; then
      echo "${base}@${digest}"
      return 0
    fi
  fi

  if docker pull "$base" >/dev/null 2>&1; then
    local repo_digest=""
    repo_digest=$(docker image inspect "$base" --format '{{index .RepoDigests 0}}' 2>/dev/null | head -n1 || true)
    if [[ -n "$repo_digest" ]]; then
      echo "$repo_digest"
      return 0
    fi
  fi

  echo "$ref"
}

lane="$1"; shift || true
case "$lane" in
  main|work|codex) ;;
  *)
    echo "invalid lane '$lane' (expected main, work, codex)" >&2
    usage
    exit 2
    ;;
esac

interactive=false
auto_password=false
pg_password=""
edge_env_file=""
force=false
pg_super_role=""
pg_super_password=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --interactive)
      interactive=true
      shift
      ;;
    --pg-password)
      pg_password="${2:?missing password value}"
      shift 2
      ;;
    --edge-env-file)
      edge_env_file="${2:?missing edge env path}"
      shift 2
      ;;
    --force)
      force=true
      shift
      ;;
    --random-pg-password)
      auto_password=true
      shift
      ;;
    --pg-super-role)
      pg_super_role="${2:?missing superuser role value}"
      shift 2
      ;;
    --pg-super-password)
      pg_super_password="${2:?missing superuser password value}"
      shift 2
      ;;
    *)
      echo "unknown option '$1'" >&2
      usage
      exit 2
      ;; 
  esac
done

generated_password=false

root="$(cd "$(dirname "$0")/../.." && pwd)"
lanes_dir="$root/ops/supabase/lanes"
mkdir -p "$lanes_dir"

superusers_file="$lanes_dir/superusers.env"

ensure_superusers_file() {
  if [[ ! -f "$superusers_file" ]]; then
    echo "ℹ️  Creating $superusers_file with restricted permissions." >&2
    old_umask="$(umask)"
    umask 177
    {
      echo "# Supabase lane superuser credentials"
      echo "# Generated by provision_lane_env.sh"
      echo "# Format: <LANE>_SUPER_ROLE=<role>"
      echo "#         <LANE>_SUPER_PASSWORD=<password>"
    } >"$superusers_file"
    umask "$old_umask"
    chmod 600 "$superusers_file"
  fi
}

update_superuser_kv() {
  local key="$1"
  local value="$2"
  local tmp
  tmp=$(mktemp)
  awk -v key="$key" -v value="$value" '
    BEGIN { updated = 0 }
    $0 ~ "^" key "=" {
      print key "=" value
      updated = 1
      next
    }
    { print }
    END {
      if (updated == 0) {
        print key "=" value
      }
    }
  ' "$superusers_file" >"$tmp"
  mv "$tmp" "$superusers_file"
  chmod 600 "$superusers_file"
}

lane_upper="${lane^^}"
role_key="${lane_upper}_SUPER_ROLE"
password_key="${lane_upper}_SUPER_PASSWORD"

config_super_role=""
config_super_password=""
if [[ -f "$superusers_file" ]]; then
  # shellcheck disable=SC1090
  set -a; source "$superusers_file"; set +a
  config_super_role="${!role_key:-}"
  config_super_password="${!password_key:-}"
fi

env_file="$lanes_dir/${lane}.env"

existing_pg_password=""
existing_edge_env_file=""
existing_jwt_secret=""
existing_anon_key=""
existing_service_key=""
existing_super_role=""
existing_super_password=""
if [[ -f "$env_file" ]]; then
  # shellcheck disable=SC1090
  set -a; source "$env_file"; set +a
  existing_pg_password="${PGPASSWORD:-}"
  existing_edge_env_file="${EDGE_ENV_FILE:-}"
  existing_jwt_secret="${JWT_SECRET:-}"
  existing_anon_key="${ANON_KEY:-}"
  existing_service_key="${SERVICE_ROLE_KEY:-}"
  existing_super_role="${SUPABASE_SUPER_ROLE:-}"
  existing_super_password="${SUPABASE_SUPER_PASSWORD:-}"
fi

case "$lane" in
  main)
    pg_port=5433
    pg_db="vibe_main"
    kong_port=8101
    edge_port=9901
    default_edge_env="/etc/supabase/edge-main.env"
    ;;
  work)
    pg_port=5434
    pg_db="vibe_work"
    kong_port=8102
    edge_port=9902
    default_edge_env="/etc/supabase/edge-work.env"
    ;;
  codex)
    pg_port=5435
    pg_db="vibe_codex"
    kong_port=8103
    edge_port=9903
    default_edge_env="/etc/supabase/edge-codex.env"
    ;;
  *)
    echo "unsupported lane '$lane'" >&2
    exit 2
    ;; 
esac

if [[ -z "$edge_env_file" ]]; then
  if [[ -n "$existing_edge_env_file" ]]; then
    edge_env_file="$existing_edge_env_file"
  else
    edge_env_file="$default_edge_env"
  fi
fi

if [[ -z "$pg_super_role" ]]; then
  if [[ -n "$config_super_role" ]]; then
    pg_super_role="$config_super_role"
  elif [[ -n "$existing_super_role" ]]; then
    pg_super_role="$existing_super_role"
  else
    pg_super_role="supabase_admin_${lane}"
  fi
fi

if [[ -z "$pg_super_password" ]]; then
  if [[ -n "$config_super_password" ]]; then
    pg_super_password="$config_super_password"
  elif [[ -n "$existing_super_password" ]]; then
    pg_super_password="$existing_super_password"
  elif [[ -n "$pg_password" ]]; then
    pg_super_password="$pg_password"
  else
    pg_super_password="$(openssl rand -hex 32)"
  fi
fi

ensure_superusers_file
update_superuser_kv "$role_key" "$pg_super_role"
update_superuser_kv "$password_key" "$pg_super_password"

if [[ -z "$pg_password" ]]; then
  if [[ -n "$existing_pg_password" ]]; then
    pg_password="$existing_pg_password"
  elif [[ "$interactive" == true ]]; then
    read -rsp "Enter Postgres password for lane '$lane': " pg_password
    echo
    if [[ -z "$pg_password" ]]; then
      echo "password cannot be empty" >&2
      exit 2
    fi
  else
    auto_password=true
  fi
fi

if [[ "$auto_password" == true && -z "$pg_password" ]]; then
  pg_password="$(openssl rand -hex 32)"
  generated_password=true
fi

if [[ -z "$pg_super_password" && -n "$pg_password" ]]; then
  pg_super_password="$pg_password"
fi

if [[ -z "$pg_super_role" ]]; then
  echo "superuser role must not be empty" >&2
  exit 2
fi

if [[ -z "$pg_super_password" ]]; then
  echo "superuser password must not be empty; supply --pg-super-password or rerun with existing lane file" >&2
  exit 2
fi

images_lock="$root/ops/supabase/images.lock.json"
if [[ ! -f "$images_lock" ]]; then
  echo "images lock file $images_lock not found" >&2
  exit 1
fi

mapfile -t image_entries < <(jq -r '.images | to_entries[] | "\(.key)=\(.value)"' "$images_lock")

declare -A lock_images=()
for entry in "${image_entries[@]}"; do
  key="${entry%%=*}"
  value="${entry#*=}"
  lock_images["$key"]="$value"
done

lock_updated=false
if [[ "$docker_available" == true ]]; then
  for key in "${!lock_images[@]}"; do
    resolved=$(resolve_image_pin "${lock_images[$key]}")
    if [[ -n "$resolved" && "$resolved" != "${lock_images[$key]}" ]]; then
      lock_images["$key"]="$resolved"
      lock_updated=true
    fi
  done
fi

if [[ "$lock_updated" == true ]]; then
  tmp_map=$(mktemp)
  for entry in "${image_entries[@]}"; do
    key="${entry%%=*}"
    printf '%s=%s\n' "$key" "${lock_images[$key]}" >> "$tmp_map"
  done
  python3 - "$images_lock" "$tmp_map" <<'PY'
import json, os, sys
lock_path = sys.argv[1]
map_path = sys.argv[2]
with open(lock_path, 'r', encoding='utf-8') as fh:
    data = json.load(fh)
images = data.setdefault('images', {})
with open(map_path, 'r', encoding='utf-8') as fh:
    for line in fh:
        line = line.strip()
        if not line:
            continue
        key, value = line.split('=', 1)
        images[key] = value
tmp_path = lock_path + '.tmp'
with open(tmp_path, 'w', encoding='utf-8') as fh:
    json.dump(data, fh, indent=2)
    fh.write('\n')
os.replace(tmp_path, lock_path)
PY
  rm -f "$tmp_map"
fi

needs_update=false
explicit_update=false
if [[ -n "$pg_password" && -z "$existing_pg_password" ]]; then
  needs_update=true
elif [[ -n "$pg_password" && "$pg_password" != "$existing_pg_password" ]]; then
  explicit_update=true
fi

if [[ -n "$edge_env_file" && "$edge_env_file" != "$existing_edge_env_file" ]]; then
  explicit_update=true
fi

required_vars=(
  COMPOSE_PROJECT_NAME LANE VOL_NS
  PGHOST PGPORT PGDATABASE PGUSER PGPASSWORD
  SUPABASE_SUPER_ROLE SUPABASE_SUPER_PASSWORD
  KONG_HTTP_PORT EDGE_PORT EDGE_ENV_FILE
  JWT_SECRET ANON_KEY SERVICE_ROLE_KEY
)

image_vars=(DB_IMAGE AUTH_IMAGE REST_IMAGE REALTIME_IMAGE STORAGE_IMAGE IMGPROXY_IMAGE EDGE_IMAGE KONG_IMAGE)

if [[ -f "$env_file" ]]; then
  for var in "${required_vars[@]}"; do
    if [[ -z "${!var:-}" ]]; then
      needs_update=true
      break
    fi
  done
  for var in "${image_vars[@]}"; do
    if [[ -z "${!var:-}" ]]; then
      needs_update=true
      break
    fi
    if [[ "${!var}" != "${lock_images[$var]}" ]]; then
      needs_update=true
      break
    fi
  done
fi

if [[ ! -f "$env_file" ]]; then
  needs_update=true
fi

if [[ "$force" != true && "$needs_update" != true && "$explicit_update" != true ]]; then
  echo "ℹ️  Environment file $env_file already satisfies requirements; skipping." >&2
  exit 0
fi

jwt_secret="$existing_jwt_secret"
if [[ -z "$jwt_secret" ]]; then
  jwt_secret="$(openssl rand -base64 32)"
fi

anon_key="$existing_anon_key"
if [[ -z "$anon_key" ]]; then
  anon_key="$(openssl rand -hex 32)"
fi

service_role_key="$existing_service_key"
if [[ -z "$service_role_key" ]]; then
  service_role_key="$(openssl rand -hex 32)"
fi

old_umask="$(umask)"
umask 177
cat >"$env_file" <<ENV
# Generated by provision_lane_env.sh on $(date -u +%Y-%m-%dT%H:%M:%SZ)
COMPOSE_PROJECT_NAME=supa-${lane}
LANE=${lane}
VOL_NS=${lane}

PGHOST=127.0.0.1
PGPORT=${pg_port}
PGDATABASE=${pg_db}
PGUSER=postgres
PGPASSWORD=${pg_password}
SUPABASE_SUPER_ROLE=${pg_super_role}
SUPABASE_SUPER_PASSWORD=${pg_super_password}

KONG_HTTP_PORT=${kong_port}
EDGE_PORT=${edge_port}
EDGE_ENV_FILE=${edge_env_file}

JWT_SECRET=${jwt_secret}
ANON_KEY=${anon_key}
SERVICE_ROLE_KEY=${service_role_key}

# Image pins (managed via ops/supabase/images.lock.json)
DB_IMAGE=${lock_images[DB_IMAGE]}
AUTH_IMAGE=${lock_images[AUTH_IMAGE]}
REST_IMAGE=${lock_images[REST_IMAGE]}
REALTIME_IMAGE=${lock_images[REALTIME_IMAGE]}
STORAGE_IMAGE=${lock_images[STORAGE_IMAGE]}
IMGPROXY_IMAGE=${lock_images[IMGPROXY_IMAGE]}
EDGE_IMAGE=${lock_images[EDGE_IMAGE]}
KONG_IMAGE=${lock_images[KONG_IMAGE]}
ENV
chmod 600 "$env_file"
umask "$old_umask"

if [[ "$generated_password" == true ]]; then
  echo "ℹ️  Generated a random Postgres password for lane '$lane'. The value is stored inside $env_file." >&2
fi

cat <<'NOTE'
⚠️  Temporary Supabase API keys generated. Replace JWT_SECRET, ANON_KEY, and SERVICE_ROLE_KEY with production keys issued by your Supabase tooling before going live.
NOTE

echo "✅ Wrote $env_file with permissions 600"
