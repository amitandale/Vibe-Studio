name: Deploy to VPS
on:
  workflow_dispatch:
concurrency:
  group: deploy-vps
  cancel-in-progress: false
jobs:
  deploy:
    name: Build and Deploy
    runs-on: self-hosted
    environment:
      name: production
    steps:
      - name: Set deployment variables
        id: vars
        run: |
          BRANCH="${{ github.ref_name }}"
          if [[ "$BRANCH" == "main" ]]; then
            echo "port=3000" >> $GITHUB_OUTPUT
            echo "deploy_dir=${{ github.workspace }}/vibe-main" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH" == "work" ]]; then
            echo "port=3001" >> $GITHUB_OUTPUT
            echo "deploy_dir=${{ github.workspace }}/vibe-work" >> $GITHUB_OUTPUT
          elif [[ "$BRANCH" == codex/* ]]; then
            echo "port=3002" >> $GITHUB_OUTPUT
            echo "deploy_dir=${{ github.workspace }}/vibe-codex" >> $GITHUB_OUTPUT
          else
            echo "port=3000" >> $GITHUB_OUTPUT
            echo "deploy_dir=${{ github.workspace }}/vibe-main" >> $GITHUB_OUTPUT
          fi

      - name: Repair lane workspace ownership
        shell: bash
        run: |
          set -euo pipefail

          repair_tree() {
            local path="$1"
            if sudo test -d "$path"; then
              echo "‚ÑπÔ∏è  Repairing workspace ownership for $path"
              sudo chown -R "$(id -u)":"$(id -g)" "$path"
            fi
          }

          repair_tree "${{ github.workspace }}"
          repair_tree "${{ steps.vars.outputs.deploy_dir }}"

      - name: Create deployment directory
        run: mkdir -p ${{ steps.vars.outputs.deploy_dir }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          path: ${{ steps.vars.outputs.deploy_dir }}

      - name: Fetch official Supabase docker assets
        shell: bash
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: |
          set -euo pipefail

          upstream_dir="ops/supabase/lanes/latest-docker"
          tmp_dir="$(mktemp -d)"

          echo "Cloning Supabase docker assets via sparse checkout"
          git clone --filter=blob:none --sparse https://github.com/supabase/supabase.git "$tmp_dir/supabase"
          pushd "$tmp_dir/supabase" >/dev/null
          git sparse-checkout set docker
          git rev-parse HEAD > "$OLDPWD/supabase_commit.txt"
          popd >/dev/null

          rm -rf "$upstream_dir"
          mkdir -p "$upstream_dir"
          cp -a "$tmp_dir/supabase/docker/." "$upstream_dir/"

          cp "$upstream_dir/docker-compose.yml" ops/supabase/lanes/latest-docker-compose.yml
          cp "$upstream_dir/.env.example" ops/supabase/lanes/latest-docker.env

          commit_sha="$(cat supabase_commit.txt)"
          rm -f supabase_commit.txt
          rm -rf "$tmp_dir"

          echo "Fetched Supabase docker assets at commit $commit_sha"
          echo "Compose directory: $upstream_dir"
          echo "Compose file: ops/supabase/lanes/latest-docker-compose.yml"
          echo "Env template: ops/supabase/lanes/latest-docker.env"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set lane from branch
        id: lane
        shell: bash
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: |
          lane=""
          case "${GITHUB_REF_NAME}" in
            main)
              lane="main"
              ;;
            work)
              lane="work"
              ;;
            codex/*)
              lane="codex"
              ;;
            *)
              echo "LANE=unknown" >> "$GITHUB_ENV"
              exit 1
              ;;
          esac
          echo "LANE=${lane}" >> "$GITHUB_ENV"
          echo "lane=${lane}" >> "$GITHUB_OUTPUT"

      - name: Configure Supabase state directory
        shell: bash
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: |
          state_root="${{ steps.vars.outputs.deploy_dir }}/../.supabase-state"
          mkdir -p "$state_root/lanes"
          chmod 700 "$state_root" "$state_root/lanes"
          echo "SUPABASE_STATE_DIR=$state_root" >> "$GITHUB_ENV"

      - name: Ensure lane environment is provisioned
        shell: bash
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: scripts/supabase/provision_lane_env.sh "$LANE"

      - name: Validate lane environment exists
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          envfile="${{ steps.vars.outputs.deploy_dir }}/ops/supabase/lanes/${LANE}.env"
          if [ ! -s "$envfile" ]; then
            echo "‚ùå Lane env file missing or empty: $envfile"
            echo ""
            echo "To fix this, SSH to the runner and run:"
            echo "  cd ${{ steps.vars.outputs.deploy_dir }}"
            echo "  ./scripts/supabase/provision_lane_env.sh $LANE --interactive --pg-super-role supabase_admin"
            echo ""
            echo "See docs/SUPABASE_SETUP.md for complete instructions."
            exit 1
          fi

          if ! scripts/supabase/validate_lane_env.sh "$LANE"; then
            echo ""
            echo "üö® Lane environment not configured!"
            echo ""
            echo "To fix this, SSH to the runner and run:"
            echo "  cd ${{ steps.vars.outputs.deploy_dir }}"
            echo "  ./scripts/supabase/provision_lane_env.sh $LANE --interactive --pg-super-role supabase_admin"
            echo ""
            echo "See docs/SUPABASE_SETUP.md for complete instructions."
            exit 1
          fi

      - name: Refresh Supabase images
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          set -euo pipefail

          envfile="ops/supabase/lanes/${LANE}.env"
          compose_dir="ops/supabase/lanes/latest-docker"
          compose_file="ops/supabase/lanes/latest-docker-compose.yml"

          override_file="ops/supabase/lanes/docker-compose.override.yml"
          lane_override="ops/supabase/lanes/docker-compose.${LANE}.yml"

          echo "‚ÑπÔ∏è  Refreshing Supabase images"
          echo "   Lane: $LANE"
          echo "   Env file: $(realpath "$envfile")"
          echo "   Compose directory: $(realpath "$compose_dir")"
          echo "   Compose file: $(realpath "$compose_file")"

          compose_args=(
            --project-directory "$compose_dir"
            --env-file "$envfile"
            -f "$compose_file"
          )

          if [[ -f "$override_file" ]]; then
            echo "   Compose override: $(realpath "$override_file")"
            compose_args+=(-f "$override_file")
          fi

          if [[ -f "$lane_override" ]]; then
            echo "   Compose override: $(realpath "$lane_override")"
            compose_args+=(-f "$lane_override")
          fi

          if [[ ! -f "$envfile" ]]; then
            echo "‚ùå Lane env file missing: $envfile" >&2
            exit 1
          fi

          if [[ ! -d "$compose_dir" ]]; then
            echo "‚ùå Supabase compose directory missing: $compose_dir" >&2
            exit 1
          fi

          if [[ ! -f "$compose_file" ]]; then
            echo "‚ùå Supabase compose definition missing: $compose_file" >&2
            exit 1
          fi

          echo "‚ÑπÔ∏è  Aligning images with $(basename "$compose_file")"
          docker compose "${compose_args[@]}" pull

          echo "‚ÑπÔ∏è  Supabase images after pull"
          docker compose "${compose_args[@]}" images

          echo "‚ÑπÔ∏è  Images referenced by compose definition"
          docker compose "${compose_args[@]}" config --images

      - name: Capture Supabase lane state
        id: supabase_state
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          envfile="ops/supabase/lanes/${LANE}.env"
          compose_file="ops/supabase/lanes/latest-docker-compose.yml"
          echo "‚ÑπÔ∏è  Capturing Supabase lane state"
          echo "   Lane: $LANE"
          echo "   Env file: $(realpath "$envfile")"
          echo "   Compose file: $(realpath "$compose_file")"
          if [[ ! -f "$envfile" ]]; then
            echo "volume_present=false" >> "$GITHUB_OUTPUT"
            echo "running=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "‚ÑπÔ∏è  Invoking scripts/supabase/lane.sh $LANE status"
          set -a
          # shellcheck disable=SC1090
          source "$envfile"
          set +a
          volume_name="supa-${VOL_NS}-db"
          if docker volume inspect "$volume_name" >/dev/null 2>&1; then
            echo "volume_present=true" >> "$GITHUB_OUTPUT"
          else
            echo "volume_present=false" >> "$GITHUB_OUTPUT"
          fi
          set +e
          scripts/supabase/lane.sh "$LANE" status
          status=$?
          set -e
          if [[ $status -eq 0 ]]; then
            echo "running=true" >> "$GITHUB_OUTPUT"
          else
            echo "running=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è  Supabase lane status check returned exit code $status for lane '$LANE'; continuing with phased redeploy." >&2
          fi

      - name: Stop lane services and bring DB up
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          echo "‚ÑπÔ∏è  Preparing to stop Supabase lane services for lane $LANE"
          if [[ "${{ steps.supabase_state.outputs.running }}" == "true" ]]; then
            echo "‚ÑπÔ∏è  Lane $LANE previously running; invoking stop command"
            scripts/supabase/lane.sh "$LANE" stop
          else
            echo "Supabase lane $LANE was not running prior to deploy; skip stop."
          fi
          echo "‚ÑπÔ∏è  Starting Postgres-only mode for migrations"
          scripts/supabase/lane.sh "$LANE" db-only
          scripts/supabase/lane.sh "$LANE" db-health

      - name: Validate Supabase db-only services
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
          LANE_STATUS_REQUIRED_SERVICES: "db vector"
        run: |
          echo "‚ÑπÔ∏è  Validating db-only Supabase services for lane $LANE"
          scripts/supabase/lane.sh "$LANE" status

      - name: Apply DB migrations (transactional + advisory lock)
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: scripts/supabase/migrate.sh "$LANE"

      - name: Start lane services
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          echo "‚ÑπÔ∏è  Starting Supabase services for lane $LANE"
          if [[ "${{ steps.supabase_state.outputs.running }}" == "true" || "${{ steps.supabase_state.outputs.volume_present }}" != "true" ]]; then
            echo "‚ÑπÔ∏è  Running scripts/supabase/lane.sh $LANE start to launch full stack"
            scripts/supabase/lane.sh "$LANE" start
            echo "‚ÑπÔ∏è  scripts/supabase/lane.sh $LANE start completed"
          else
            echo "Supabase lane $LANE was previously stopped; removing transient db-only container."
            scripts/supabase/lane.sh "$LANE" stop
          fi

      - name: Wait for Kong health
        if: steps.supabase_state.outputs.running == 'true' || steps.supabase_state.outputs.volume_present != 'true'
        shell: bash
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          KONG_PORT=$(grep -E '^KONG_HTTP_PORT=' "ops/supabase/lanes/${LANE}.env" | cut -d= -f2)
          ops/bin/healthwait.sh "http://127.0.0.1:${KONG_PORT}" 120

      - name: Reload Edge runtime
        if: steps.supabase_state.outputs.running == 'true' || steps.supabase_state.outputs.volume_present != 'true'
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: scripts/supabase/edge_deploy.sh "$LANE"

      - name: Validate Supabase full stack services
        if: steps.supabase_state.outputs.running == 'true' || steps.supabase_state.outputs.volume_present != 'true'
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        env:
          LANE: ${{ steps.lane.outputs.lane }}
        run: |
          echo "‚ÑπÔ∏è  Validating full Supabase stack for lane $LANE"
          scripts/supabase/lane.sh "$LANE" status

      - name: Normalize Supabase workspace permissions
        if: always()
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: |
          set -euo pipefail

          lane_root="$(pwd)"
          state_dir="${lane_root}/../.supabase-state"

          if [[ -d "${lane_root}/ops/supabase/lanes" ]]; then
            sudo chown -R "$(id -u)":"$(id -g)" "${lane_root}/ops/supabase/lanes"
          fi

          if [[ -d "$state_dir" ]]; then
            sudo chown -R "$(id -u)":"$(id -g)" "$state_dir"
          fi

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable Corepack
        run: corepack enable

      - name: Activate pnpm from packageManager field
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: corepack prepare $(node -p "require('./package.json').packageManager") --activate

      - name: Add pnpm to PATH
        run: echo "$(corepack --help &>/dev/null && dirname $(which corepack))" >> $GITHUB_PATH

      - name: Verify pnpm installation
        run: |
          which pnpm
          pnpm --version

      - name: Install dependencies
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: pnpm install --frozen-lockfile

      - name: Build Next.js application
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: pnpm run build

      # - name: Prune to production dependencies
      #   run: pnpm prune --prod

      - name: Open port for application access
        run: sudo ufw allow ${{ steps.vars.outputs.port }}/tcp

      - name: Stop all PM2 processes on this port
        run: |
          PORT=${{ steps.vars.outputs.port }}
          echo "Cleaning up all PM2 processes using port $PORT..."
          
          # Get all PM2 processes and check which ones are using this port
          pm2 jlist | jq -r '.[] | select(.pm2_env.env.PORT == "'$PORT'") | .name' 2>/dev/null | while read proc_name; do
            if [ -n "$proc_name" ]; then
              echo "Deleting PM2 process using port $PORT: $proc_name"
              pm2 delete "$proc_name" || true
            fi
          done
          
          # Also try to delete by current branch name as fallback
          pm2 delete ${{ github.ref_name }} || true

      - name: Kill orphaned processes on port
        run: |
          PORT=${{ steps.vars.outputs.port }}
          PIDS=$(sudo lsof -t -i :$PORT || true)
          if [ -n "$PIDS" ]; then
            echo "Killing orphaned processes on port $PORT (PIDs: $PIDS)"
            sudo kill -9 $PIDS
          else
            echo "No processes found on port $PORT - port is clear"
          fi

      - name: Start application with PM2
        working-directory: ${{ steps.vars.outputs.deploy_dir }}
        run: |
          PORT=${{ steps.vars.outputs.port }} pm2 start pnpm --name ${{ github.ref_name }} -- run start
          pm2 save

      - name: Show deployment summary
        run: |
          PUBLIC_IP=$(curl -4 ifconfig.me)
          echo "‚úÖ Deployment completed successfully!"
          echo "üì¶ Branch: ${{ github.ref_name }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üîó App Link: http://$PUBLIC_IP:${{ steps.vars.outputs.port }}"
          echo "üìÅ Deploy Dir: ${{ steps.vars.outputs.deploy_dir }}"
